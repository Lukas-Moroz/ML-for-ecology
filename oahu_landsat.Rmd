=======
---
title: "Clean Raw Landsat"
author: "Madeline Berger"
date: "2025-07-30"
output: html_document

updated by Alana Wesly
07/30/2025
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# load packages 

library(terra)
library(tidyverse)
library(here) # I use this to easily create relative file paths

# added to update column names

library(dplyr) # Load dplyr

# added for cluster visualization

library(ggplot2)
library(ggpubr) # For stat_ellipse

# set file path to data folder 

oahu_raw_data <- here("low_resolution/oahu")


```

Read in one raster and convert to data frame (as an example)

```{r}

first_rast <- terra::rast(file.path(oahu_raw_data,"Oahu_2014_LS8_composite_low_resolution.tif")) #read in the tif file as a SpatRaster using terra

first_rast # get summary of whats in the raster

nlyr(first_rast) # there are the bands

# what happens when we run as data frame


first_df <- as.data.frame(first_rast, xy = T)


```

Loop to read in each raster and convert to data frame. The steps will:
- run through each file and read it in as a Spat Raster
- create a df of each
- save each one in a list with a new column for year

Understanding the df: x and y are the location coordinates, SR_B# is the visual band
- Updating the df band number column names to be human readable

```{r}

# list each landsat raster

tif_files <- list.files(oahu_raw_data,
                        pattern = ".tif")

# create empty list

df_list <- list()

for (i in 1:length(tif_files)){
  
  # for testing
 # i = 1
  
  # file name
  f = tif_files[i]
  
  # get year from file name
  year = substr(f,6,9)
  
  # read in raster
  rast = terra::rast(file.path(oahu_raw_data,f))
  
  # convert to df, add column with year
  
  df <- as.data.frame(rast, xy = T) %>% mutate(image_year = rep(year, nrow(.)))
  
  # rename band numbers to the human readable name
  df <- df %>%
    rename(Coastal_Aerosol = SR_B1,
           Blue = SR_B2,
           Green = SR_B3,
           Red = SR_B4,
           Near_Infrared = SR_B5,
           Shortwave_Infrared_1= SR_B6,
           Shortwave_Infrared_2= SR_B7)
  
  # save to list 

  df_list[[i]] <- df
  
}


# now we have a list of dfs for each year 


```

Find clusters with k-means clustering for whole group and then separate into years 

```{r}
# Set seed for consistency
set.seed(123)

# Combine all data for clustering
combined_df <- do.call(rbind, df_list)

# Extract numeric columns and scale
df_numeric_all <- scale(combined_df[, !names(combined_df) %in% c("x", "y", "image_year")])

# Run k-means on all data together
kmeans_all <- kmeans(df_numeric_all, centers = 5, nstart = 20, iter.max = 100)

# Add cluster assignments back to combined data
combined_df$cluster <- kmeans_all$cluster

# Split back into individual years
df_list_new <- split(combined_df, combined_df$image_year)

# Convert back to list format matching original structure
df_list <- lapply(names(df_list_new), function(year) {
  df_list_new[[year]]
})

# Print cluster distributions for each year
for (i in seq_along(df_list)) {
  year <- unique(df_list[[i]]$image_year)
  cat("Year", year, "cluster distribution:\n")
  print(table(df_list[[i]]$cluster))
}
```

Visualize the color coded clusters by year with ggplot2

```{r}
# First, check what clusters exist across all years
all_clusters <- unique(unlist(lapply(df_list, function(df) unique(df$cluster))))
cat("Clusters found across all years:", sort(all_clusters), "\n")

# Define colors for all possible clusters
cluster_colors <- c("1" = "#ccdb41", "2" = "#4ebcff", "3" = "#a4d280", 
                    "4" = "#78c7c1", "5" = "#f7e501")

cluster_plots <- list()

for (i in seq_along(df_list)) {
  year <- unique(df_list[[i]]$image_year)
  
  # Ensure cluster column is a factor with all levels
  df_list[[i]]$cluster <- factor(df_list[[i]]$cluster, levels = 1:5)
  
  cluster_plots[[i]] <- ggplot(df_list[[i]], aes(x = x, y = y, color = cluster)) +
    geom_point(size = 0.5, alpha = 0.7) +
    scale_color_manual(name = "Cluster", 
                       values = cluster_colors,
                       breaks = factor(1:5),
                       drop = FALSE) +  # Keep all levels even if not present
    labs(title = paste("K-means Clusters -", year),
         x = "Longitude", 
         y = "Latitude") +
    theme_minimal() +
    theme(axis.text = element_text(size = 8),
          plot.title = element_text(size = 12, hjust = 0.5)) +
    coord_fixed(ratio = 1)
  
  print(cluster_plots[[i]])
}

```

Visualize the combined plots with ggplot2 

```{r}

combined_tile_plot <- ggplot(combined_df, aes(x = x, y = y, fill = factor(cluster))) +
  geom_tile() +  # Use tiles for clean appearance
  scale_fill_manual(name = "Cluster", values = cluster_colors) +
  labs(title = "K-means Clusters - All Years Combined",
       subtitle = paste("Years:", paste(sort(unique(combined_df$image_year)), collapse = ", ")),
       x = "Longitude", 
       y = "Latitude") +
  theme_minimal() +
  theme(panel.grid = element_blank(),  # Remove all grid lines
        axis.text = element_text(size = 8),
        plot.title = element_text(size = 14, hjust = 0.5),
        plot.subtitle = element_text(size = 10, hjust = 0.5)) +
  coord_fixed(ratio = 1)

print(combined_tile_plot)

```

Visualize the combined plots using groupby on cooridinates and the mode cluster 

```{r}

library(dplyr)

# Group by coordinates and find the most common cluster (mode)
get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

# Aggregate data by coordinates
aggregated_df <- combined_df %>%
  group_by(x, y) %>%
  summarise(
    dominant_cluster = get_mode(cluster),
    cluster_count = n(),
    cluster_consistency = sum(cluster == dominant_cluster) / n(),
    .groups = 'drop'
  )

# Plot dominant clusters
dominant_cluster_plot <- ggplot(aggregated_df, aes(x = x, y = y, fill = factor(dominant_cluster))) +
  geom_raster() +
  scale_fill_manual(name = "Dominant\nCluster", values = cluster_colors) +
  labs(title = "Dominant Clusters Across All Years Using the Mode of Clusters",
       subtitle = "Most common cluster at each location",
       x = "Longitude", 
       y = "Latitude") +
  theme_void() +
  theme(plot.title = element_text(size = 14, hjust = 0.5),
        plot.subtitle = element_text(size = 10, hjust = 0.5),
        legend.position = "bottom") +
  coord_fixed(ratio = 1)

print(dominant_cluster_plot)

```
Visualize the combined plots using groupby on coordinates, averaging the cluster number by year

```{r}
library(patchwork)

# Create all three plots
plot1 <- ggplot(spatial_summary, aes(x = x, y = y, fill = factor(mode_cluster))) +
  geom_raster() +
  scale_fill_manual(name = "Mode\nCluster", values = cluster_colors) +
  labs(title = "Mode Cluster", x = "Longitude", y = "Latitude") +
  theme_void() + coord_fixed(ratio = 1)

plot2 <- ggplot(spatial_summary, aes(x = x, y = y, fill = factor(round(mean_cluster)))) +
  geom_raster() +
  scale_fill_manual(name = "Rounded\nMean", values = cluster_colors) +
  labs(title = "Rounded Mean Cluster", x = "Longitude", y = "Latitude") +
  theme_void() + coord_fixed(ratio = 1)

# Combine plots
combined_comparison <- plot1 / plot2 +
  plot_annotation(title = "Cluster Summary Comparison")

print(combined_comparison)
```
Validate k clusters model with subset of original data

```{r}
# Use original centroids as starting points for subset model
# This ensures clusters will be more similar

# Get the original scaling parameters
original_scaling_params <- list(
  center = attr(df_numeric_all, "scaled:center"),
  scale = attr(df_numeric_all, "scaled:scale")
)

# Scale training data using original parameters
train_features_original_scale <- scale(train_data[, training_columns], 
                                      center = original_scaling_params$center, 
                                      scale = original_scaling_params$scale)

# Use original centroids as starting points
kmeans_subset_fixed <- kmeans(train_features_original_scale, 
                             centers = kmeans_all$centers,  # Use original centroids
                             nstart = 1,  # Only one start since we provide centers
                             iter.max = 100)

# Now predict using this model
predict_with_fixed_centers <- function(new_data, original_centers, scaling_params, training_columns) {
  # Extract and scale data
  new_data_subset <- new_data[, training_columns, drop = FALSE]
  new_data_scaled <- scale(new_data_subset, 
                          center = scaling_params$center, 
                          scale = scaling_params$scale)
  
  # Calculate distances to original centroids
  distances <- apply(new_data_scaled, 1, function(x) {
    apply(original_centers, 1, function(center) {
      sum((x - center)^2)
    })
  })
  
  # Assign to closest centroid
  cluster_assignments <- apply(distances, 2, which.min)
  return(cluster_assignments)
}

# Apply to test data
test_predictions_fixed <- test_data
test_predictions_fixed$predicted_cluster <- predict_with_fixed_centers(test_data, 
                                                                      kmeans_all$centers, 
                                                                      original_scaling_params, 
                                                                      training_columns)

# Compare results
cat("\nUsing fixed centroids approach:\n")
print("Original:")
print(table(test_data$cluster))
print("Predicted (fixed centroids):")
print(table(test_predictions_fixed$predicted_cluster))

agreement_fixed <- sum(test_data$cluster == test_predictions_fixed$predicted_cluster) / nrow(test_data)
cat("Agreement rate (fixed centroids):", round(agreement_fixed * 100, 2), "%\n")

```
Visualize validation

```{r}
library(ggplot2)

# Create comparison plots
cluster_colors <- c("1" = "#ccdb41", "2" = "#4ebcff", "3" = "#a4d280", 
                    "4" = "#78c7c1", "5" = "#f7e501")

# Original clusters on test data
original_plot <- ggplot(test_data, aes(x = x, y = y, fill = factor(cluster))) +
  geom_raster() +
  scale_fill_manual(name = "Original\nCluster", values = cluster_colors) +
  labs(title = "Original Clusters (Test Data)", x = "Longitude", y = "Latitude") +
  theme_void() +
  coord_fixed(ratio = 1)

# Predicted clusters on test data
predicted_plot <- ggplot(test_predictions, aes(x = x, y = y, fill = factor(predicted_cluster))) +
  geom_raster() +
  scale_fill_manual(name = "Predicted\nCluster", values = cluster_colors) +
  labs(title = "Predicted Clusters (Test Data)", x = "Longitude", y = "Latitude") +
  theme_void() +
  coord_fixed(ratio = 1)

# Show agreement/disagreement
test_predictions$agreement <- test_data$cluster == test_predictions$predicted_cluster

agreement_plot <- ggplot(test_predictions, aes(x = x, y = y, fill = agreement)) +
  geom_raster() +
  scale_fill_manual(name = "Agreement", 
                    values = c("TRUE" = "green", "FALSE" = "red"),
                    labels = c("Disagree", "Agree")) +
  labs(title = paste("Model Agreement:", round(agreement * 100, 1), "%"), 
       x = "Longitude", y = "Latitude") +
  theme_void() +
  coord_fixed(ratio = 1)

# Display plots
print(original_plot)
print(predicted_plot)
print(agreement_plot)

```

Test using the k clusters model on new (older) data - no built in predict() for k-clusters
(Update the data - waiting for data from Maddie)

```{r}

# Create a custom predict function for k-means
predict_kmeans <- function(kmeans_model, new_data, scale_params = NULL) {
  # If scale parameters are provided, scale the new data the same way
  if (!is.null(scale_params)) {
    new_data_scaled <- scale(new_data, 
                            center = scale_params$center, 
                            scale = scale_params$scale)
  } else {
    new_data_scaled <- new_data
  }
  
  # Calculate distances to each centroid
  distances <- apply(new_data_scaled, 1, function(x) {
    apply(kmeans_model$centers, 1, function(center) {
      sum((x - center)^2)  # Euclidean distance squared
    })
  })
  
  # Assign to closest centroid
  cluster_assignments <- apply(distances, 2, which.min)
  
  return(cluster_assignments)
}

# Save scaling parameters from your training data
scaling_params <- list(
  center = attr(df_numeric_all, "scaled:center"),
  scale = attr(df_numeric_all, "scaled:scale")
)

# Save the column names used for training
training_columns <- names(combined_df)[!names(combined_df) %in% c("x", "y", "image_year", "cluster")]

# Example: Apply to a new dataset (replace 'new_df' with your actual test data)
# new_df should have the same spectral band columns as your training data

apply_kmeans_to_new_data <- function(new_df, kmeans_model, scaling_params, training_columns) {
  
  # Check if new data has required columns
  missing_cols <- setdiff(training_columns, names(new_df))
  if (length(missing_cols) > 0) {
    stop("Missing columns in new data: ", paste(missing_cols, collapse = ", "))
  }
  
  # Extract and order columns to match training data
  new_data_subset <- new_df[, training_columns, drop = FALSE]
  
  # Apply the same scaling as training data
  new_data_scaled <- scale(new_data_subset, 
                          center = scaling_params$center, 
                          scale = scaling_params$scale)
  
  # Predict clusters
  predicted_clusters <- predict_kmeans(kmeans_model, new_data_scaled)
  
  # Add predictions back to original dataframe
  new_df$predicted_cluster <- predicted_clusters
  
  return(new_df)
}

# Example usage 
new_df_with_clusters <- apply_kmeans_to_new_data(new_test_df, kmeans_all, scaling_params, training_columns)

```

Visualize the predictions

```{r}

# Function to plot predictions with consistent colors
plot_predictions <- function(predicted_df, title = "Predicted Clusters") {
  
  cluster_colors <- c("1" = "#ccdb41", "2" = "#4ebcff", "3" = "#a4d280", 
                      "4" = "#78c7c1", "5" = "#f7e501")
  
  ggplot(predicted_df, aes(x = x, y = y, fill = factor(predicted_cluster))) +
    geom_raster() +
    scale_fill_manual(name = "Predicted\nCluster", values = cluster_colors) +
    labs(title = title, x = "Longitude", y = "Latitude") +
    theme_void() +
    coord_fixed(ratio = 1)
}

# Example usage:
plot_predictions(new_df_with_clusters, "Predictions on New Data")

```

